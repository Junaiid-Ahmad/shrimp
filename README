$Id$

--------------------------------------------------------------------------------
Table of Contents
--------------------------------------------------------------------------------
  1.   Introduction
  2.   Usage
  3.   Program Parameters
  4.   Output Format
  5.   Contact
  6.   Acknowledgements


--------------------------------------------------------------------------------
1. Introduction
--------------------------------------------------------------------------------

SHRiMP is a software package for aligning genomic reads against a target genome.
It was primarily developed with the multitudinous short reads of next generation
sequencing machines in mind, as well as Applied Biosystem's colourspace genomic
representation.

SHRiMP is actually a suite of several programs, which, employed in succession,
search for appropriate alignments, analyse the probability of alignments being
bad, and print out visual alignments for further study.

SHRiMP uses a few mechanisms to search for alignments. First, all kmers within
all source reads are generated and used as offsets into a hash table of the
reads themselves. Second, for each kmer in the genome a specified spaced seed is
applied and the resultant kmer is used to index matching reads in the genome.
For each read containing the kmer, a notation is added that a kmer hit was just
made. If 'n' kmer hits occur within 'm' genomic bases, the read and a section
of genome of length '2m' around the latest kmer hit is fed into a vectored
Smith-Waterman algorithm to generate an alignment score. If the score is
sufficient, the score and genomic offset (index) is remembered. One this process
has completed for the entire genome, all saved read/index pairs are fed into a
full Smith-Waterman algorithm, and a detailed output is generated.

The speed of execution depends largely on the spaced seed employed, the number
of desired matches within a window, the window length, and Smith-Waterman score
thresholds. For example, aligning 22e6 25-colour reads against the Ciona
Savignyi genome (173.67 Mbases) takes approximately 6.5 hours on a cluster of
200 Xeon 3.2GHz Hyperthreaded CPUs using a spaced seed of length 8, span 7, a
window lenght of 30, 2 matches per window, and a Smith-Waterman threshold of
1875 (penalties: 100 for matches, -70 mismatch, -75 gap open, -25 gap extend,
-200 crossover). For comparison, were vectored Smith-Waterman alignments run
on the same hardware with an average execution of 500e6 matrix cells/second,
it would take over 3 weeks.

The less exact the matches need to be, the larger the spaced seed weight can be,
and the faster the kmer scan runs. By decreasing the weight by one, execution
time increases by approximately a factor of four. Due to memory limitations,
weights quickly become impractical around 16. Similarly, exceedingly small
weights will offer little or no benefit over a full Smith-Waterman run. It is
the user's prerogative to balance sensitivity and resource usage (whether it be
CPU, memory, or disk space used by output).

Please note that the vectored Smith-Waterman algorithm is written specifically
for the SSE2 instruction set. Hence this program will not run on non-x86/x86_64
processors. Porting those algorithms to similar vector processors should
be relatively straightforward, however.

--------------------------------------------------------------------------------
2. Usage
--------------------------------------------------------------------------------

The distribution makes use of several programs. The first and most important
is 'rmapper'. 'rmapper' performs Smith-Waterman alignments of multiple reads
within one fasta file against one or more reftigs in other fasta files. rmapper
was designed to map a set of reads against the entire genome (all contigs and
their reverse-complements) in one invocation. Parallelism can be achieved by
splitting the set of reads into N chunks, where N is the desired level of
parallelism.

Once 'rmapper' has been run, the standard output format of all alignments
may be parsed via the 'probcalc' program. This code analyses all alignment
output, saving the top 'n' matches per read, and calculates the probability of
the match randomly occurring in the genome and matching the read, and the
normalised odds (P(read match)/P(random)). Thresholds can be set for each to
remove undesirably high or low values. Sorting can also be done on any one of
the three aforementioned parameters.

The output produced by the 'probcalc' utility is essentially a subset of
the input, with added 'pgenome', 'pchance' and 'normodds' fields. These
matches may then have their full alignments printed using the 'prettyprint'
utility (although one could certainly feed rmapper output to prettyprint
directly).

What follows is a complete example of scanning a set of reads against an
entire genome (and its reverse-complement) from the Ciona Savignyi organism.
We'll then calculate the associated probabilities and print out pretty
alignments.

We shall assume a large set of colourspace reads exist in a single file
'reads.csfasta' and the entire Ciona genome exists in 'ciona.fasta' (as a single
contig), both in the present working directory.

  1)  mkdir reads
  2)  mkdir results
  3)  cd reads
  4)  splitreads 1000 ../reads.csfasta
  5)  cd ..
  6)  rmapper-cs -s 11110111 -n 2 -t 4 -w 28 -o 10 -r 25 -m 100 -i -70 -g -100 \
          -e -70 -x -200 -h 1975 -v 1875 -B reads/0_to_999.csfasta
         ciona.fasta > results/ciona.0_to_999.out
  7) probcalc -p 0.4 -t 10 173673243 results/ > ciona.0_to_999.probcalc.out
  8) prettyprint-cs -m 100 -i -70 -g -100 -e -70 -x -200 \
         ciona.0_to_999.probcalc.out genome/ reads/

Lines 1&2 set up the necessary directory structure. reads/ contains one or more
fasta files containing letterspace or colourspace reads. results/ contains the
results of the 'rmapper' pass, which are fed to 'probcalc' to generate the
probabilities of them being poor matches.

Lines 3&4 split the reads.csfasta file, which contains a large number of
colourspace reads into smaller chunks. This both saves memory, and would allow
us to parallelise the computation.

Line 6 maps all reads split into the file 0_to_999.csfasta against ciona.fasta.
The various parameters are verbosely documented later in this file. The output
of 'rmapper' is piped into a file in the results/ directory for later
evaluation. This step could be parallelised across all *_to_*.csfasta files
created by splitreads. Note that rmapper expects each genomic file to contain
a single contig. This is not a fundamental limitation or restriction. To split
a single fasta file into constituent contigs, use the 'splittigs' program.

Line 7 calculates the probability of each hit generated by 'rmapper' of being
bad. It takes two mandatory parameters: the total concatenated genome length,
and a directory of 'rmapper' result files. The output is piped into a further
results file for later evaluation by the 'prettyprint-cs' progrma. Note that
'probcalc' should be run once enough results have been gathered to generate
reasonable statistics. Since this phase takes a relatively short amount of time,
it is probably best done once sequentially for all output generated.

Also note that probcalc mandates that results for a single read do not appear
in multiple input files. If rmapper had been run against the entire genome for
some set of reads, this would not be the case. See section 3 for details
regarding probcalc's parameters.

Line 8 prints pretty visual alignments of our resultant mappings. It requires
knowning all genomic and reads files in order to locate each read referenced in
the input file (generated by either 'rmapper' or 'probcalc') and aligns them
against the appropriate contig in the genome. Alternatively, one could have run
rmapper with the -P flag to generate these in the initial output (although that
could consume a considerable amount of disk space). Note that rmapper and
prettyprint share the same default parameters. Deviating from the defaults
in rmapper means having to provide the appropriate S-W penalties to prettyprint
as well.


--------------------------------------------------------------------------------
3. Program Parameters
--------------------------------------------------------------------------------

'rmapper' takes a variety of parameters, which differ sightly depending on
whether colour-space or letter-space reads are being employed. What follows
is a run-down of these options (in some strange, non-alphabetical order).

	rmapper-cs and rmapper-ls parameters (common parameters):
		[ -s spaced_seed ]

		The spaced seed is a single contiguous string of 0's and 1's.
		0's represent wildcards, or positions which will always be
		considered as matching, whereas 1's dictate positions that must
		match. A string of all 1's will result in a simple kmer scan.

		Note that our implementation creates a hash table based on the
		kmer size (spaced seed 'weight', or number of 1's). Hence
		memory usage increases by a factor of four for each addition
		1. At 16, we're looking at a 32GB hash table allocation for
		32-bit architectures.

		[ -n seed_matches_per_window ]

		The number of seed matches per window dictates how many seeds
		must match within some window length of the genome before that
		region is considered for Smith-Waterman alignment. A lower
		value will increase sensitivity while drastically increasing
		runnig time. Higher values will have the opposite effect.

		[ -t seed_taboo_length ]

		the seed taboo length specifies how many target genome bases
		or colours must exist prior to a previous seed match in order
		to count another seed match as a hit.

		[ -w seed_window_length ]

		This parameter specifies the genomic span in bases (or colours)
		in which 'seed_matches_per_window' must exist before the read
		is given consideration by the Smith-Waterman alignment
		machinery.

		[ -o maximum_hits_per_read ]

		This parameter specifies how many hits to remember for each
		read. If more hits are encountered, ones with lower scores are
		dropped to make room.

		[ -r maximum_read_length ]

		This parameter specifies the maximum length of reads that will
		be encountered in the dataset. If larger reads than the default
		are used, an appropriate value must be passed to 'rmapper'.

		[ -d kmer_std_dev_limit ]

		This option permits pruning read kmers, which occur with
		frequencies greater than 'kmer_std_dev_limit' standard
		deviations above the average. This can shorten running time
		at the cost of some sensitivity.

		NB: A negative value disables this option.

		[ -m sw_match_value ]

		The value applied to matches during the Smith-Waterman score
		calculation.

		[ -i sw_mismatch_value ]

		The value applied to mismatches during the Smith-Waterman score
		calculation.
		
		[ -g sw_gap_open_penalty ]

		The value applied to gap opens during the Smith-Waterman score
		calculation.

		[ -e sw_gap_extend_penalty ]

		The value applied to gap extends during the Smith-Waterman score
		calculation.

		[ -h sw_threshold ]

		NB: This option differs slightly in meaning between letter-space
		    and colour-space.

		In letter-space, this parameter determines the threshold score
		for both vectored and full Smith-Waterman alignments. Any values
		less than this quanitity will be thrown away.

		In colour-space, this parameter affects only the full Smith-
		Waterman alignment, which is performed in letter-space. The
		threshold of the colour-space fast vectored alignment can be
		specified by the -v option. Generally, the -h parameter should
		be stricter (higher) than the -v option, since naive
		colour-space alignments using regular Smith-Waterman suffer
		additionally due to artifacts such as single SNPs resulting in
		two colour mismatches.

		[ -B ]

		This option simply prints a progress bar to stderr during the
		spaced seed scan and vectored Smith-Waterman phases. It exists
		to give a general feel for run-time when testing parameters.
		Since it will slow down execution speed noticably (25% or so),
		it is not enabled by default and should only be used during
		manual, interactive execution.

		[ -P ]

		'rmapper' has two output formats. The first, and default,
		prints a list of appropriately scoring reads and various
		parameters, such as where they occurred in the genome (index),
		how many matches, mismatches, and gaps there were, and so forth.
		The '-P' flag enables a 'pretty print' output, which displays
		similar parameters, but also a full alignment.

		These alignments can also be obtained after the fact by running
		the default output file through the 'probcalc' program.

		[ -R ]

		Include the entire read sequence in the output generated. This
		will consume huge gobs of disk space for large reads and is
		disabled by default. Saved reads are placed in the 'r_seq' key.

	rmapper-cs-specific parameters: 
		[ -x crossover_penalty ]

		This specifies the penalty applied when transitioning between
		Smith-Waterman matricies during the full scan phase. While
		the vectored scan applies to colour-space, the final full
		alignment is done in letter-space. Since each next letter in
		letter-space depends on the previous letter and colour, any
		error on the colour space read will affect all following
		letters when converting to text space. For this reason, we
		must perform our alignment of all four possible letter space
		translations of the read and permit jumping between matricies
		(at the crossover_penalty) cost, when errors occur.

		[ -v sw_vector_hit_threshold ]

		Unlike in letter-space, where the vectored Smith-Waterman and
		full Smith-Waterman alignments are done both in letter-space
		and present identical scores, in colour-space the vectored
		score represents the original colour-space read aligned to
		the colour-space translation of the genome. This will differ
		from the final alignment, which is done purely in letter-space.
		Since the function of the vectored pass exists merely to prune
		insufficiently good alignments and the vectored pass is not a
		true textual alignment, scores for both passes are likely to
		differ. Generally, since a single SNP in letter-space will
		result in two colour changes, the threshold for the colour-space
		alignment should be less than that of letter-space. 

	rmapper-ls-specific parameters:
		None for now.


'prettyprint' currently takes only one optional parameter.

	prettyprint-cs and prettyprint-ls parameters (common parameters):
		[ -m sw_match_value ]

		See the 'rmapper' -m description.

		[ -i sw_mismatch_value ]

		See the 'rmapper' -i description.

		[ -g sw_gap_open_penalty ]

		See the 'rmapper' -g description.

		[ -e sw_gap_extend_penalty ]

		See the 'rmapper' -e description.

		[ -R ]

		Include the entire read sequence in the output generated. This
		will only have an effect for input lines containing the 'r_seq'
		key.

	prettyprint-cs-specific parameters:
		[ -x crossover_penalty ]

		See the 'rmapper-cs' -x description.

	prettyprint-ls-specific parameters:
		None for now.


'probcalc' takes a few optional parameters as well:
	[-n normodds_cutoff]

	Set a threshold for normodds. Any values lower than this threshold will
	be suppressed.
	
	[-o pgenome_cutoff]

	Set a threshold for pgenome. Any values lower than this threshold will
	be suppressed.
	
	[-p pchance_cutoff]

	Set a threshold for pchance. Any values higher than this threshold will
	be suppressed.

	[-s normodds|pgenome|pchance]

	Sort based on normodds, pgenome, or pchance given the appropriate
	string.

	[-t top_matches]

	Save only top_matches best matches.

	[ -B ]

	Print a progress bar to stderr during various phases of computation.

	[ -R ]
 
	Include the entire read sequence in the output generated. This
	will only have an effect for input lines containing the 'r_seq'
	key.

	[ -S ]

	Do everything in a single pass. Typically probcalc will run over all
	rmapper results files twice in order to save memory. This option will
	use one pass only at the expense of using far more memory than usual,
	however, a significant speed advantage is gained. Additionally, while
	probcalc normally mandates that each results file from rmapper contains
	matches for unique reads (no read may appear in multiple files), this
	option does not have the same restriction.


--------------------------------------------------------------------------------
4. Output Format
--------------------------------------------------------------------------------

rmapper probcalc, and prettyprint all adhere to a common output format: a
simple string of key/value pairs beginning with '>'. For example:

> r="872_553_145_F3" g="reftig_9" g_str=- score=2300 g_start=454878 g_end=454902
r_start=1 r_end=25 r_len=25 match=25 subs=0 ins=0 dels=0 xovers=1

Only lines beginning with a '>' character are parsed. This enables us to output
pretty alignments using 'rmapper' with the -P flag, or with prettyprint, while
maintaining output compatibility. '=' and '"' characters in read and reftig
names are escaped using the '\' character automatically.

Descriptions of the keys are as follows:
	'r'		Read name
	'g'		Contig (genome) name
	'g_str'		Genome strand ('+' or '-')
	'score'		Alignment score
	'g_start'	Start of alignment in genome (beginning with 1, not 0).
	'g_end'		End of alignment in genome (inclusive).
	'r_start'	Start of alignment in read (beginning with 1, not 0).
	'r_end'		End of alignment in read (inclusive).
	'r_len'		Length of the read in bases/colours.
	'match'		Number of letters matched.
	'subs'		Substitutions
	'ins'		Insertions in the base genome
	'dels'		Deletions from the base genome
	'xovers'	Colour-space only: matrix crossovers (errors) found.
	'pchance'	Probability of read matching by chance in the genome.
	'pgenome'	Probability of the read matching where it did.
	'normodds'	Normalised pgenome/pchance.


--------------------------------------------------------------------------------
5. Contact
--------------------------------------------------------------------------------

The authors of this software may be contacted at the following e-mail addresses:
	brudno at cs dot toronto dot edu	(Michael Brudno)
	rumble at cs dot toronto dot edu	(Stephen Rumble)


--------------------------------------------------------------------------------
6. Acknowledgements
--------------------------------------------------------------------------------

Development was performed at the University of Toronto's Computational
Biology lab in collaboration with the Stanford University Sidow Lab.

The development of this distribution was made possible in part by a
National Engineering and Research Council of Canada Undergraduate Student
Research Award (NSERC USRA).
