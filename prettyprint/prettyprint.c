/*	$Id$	*/

#include <assert.h>
#include <dirent.h>
#include <errno.h>
#include <inttypes.h>
#include <stdbool.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
 
#include <sys/types.h>
#include <sys/stat.h>

#include "../common/fasta.h"
#include "../common/lookup.h"
#include "../common/sw-full-common.h"
#include "../common/sw-full-cs.h"
#include "../common/sw-full-ls.h"
#include "../common/output.h"
#include "../common/util.h"

#include "../rmapper/rmapper.h"		/* for External parameters below */

/* External parameters */
static int match_value    = DEF_MATCH_VALUE;
static int mismatch_value = DEF_MISMATCH_VALUE;
static int gap_open	  = DEF_GAP_OPEN;
static int gap_extend     = DEF_GAP_EXTEND;
static int xover_penalty  = DEF_XOVER_PENALTY;

static lookup_t read_list;
static lookup_t reftig_list;

static uint64_t nread_bases;
static uint64_t nreftig_bases;
static uint32_t longest_read_len;	/* longest read we have */
static uint32_t longest_genome_len;	/* longest genome seq matched against */

/* finalpass output cache */
struct fpo {
	char       *read;		/* read into read_list */
	char       *reftig;		/* reftig into reftig_list */
	uint32_t    index_start;	/* start index within the reftig */
	uint32_t    index_end;		/* end index within the reftig */
	int32_t     score;		/* S-W score */
	struct fpo *next;		/* next alignment to do */
};

/* for read and reftig lists */
struct sequence {
	char	 *name;
	uint32_t *sequence;
	uint32_t  sequence_len;
	int	  initbp;		/* initial base pair (colourspace) */
};

static struct fpo *alignments;
static uint64_t    nalignments;

#ifdef USE_COLOURS
const int use_colours = 1;
#else
const int use_colours = 0;
#endif

#define MAX_READ_LEN	5000		/* ridiculously high upper bound */

static uint64_t
iter_reg_files(char *dir, void (*fh)(char *, char *, void *), void *arg)
{
	DIR *dp;
	struct dirent *de;
	uint64_t files;

	dp = opendir(dir);
	if (dp == NULL) {
		fprintf(stderr, "error: failed to open directory [%s]: %s\n",
		    dir, strerror(errno));
		exit(1);
	}

	files = 0;
	while (1) {
		de = readdir(dp);
		if (de == NULL)
			break;

		if (de->d_type == DT_REG && strcmp(de->d_name, ".") &&
		    strcmp(de->d_name, "..")) {
			fh(dir, de->d_name, arg);
			files++;
		}
	}

	closedir(dp);

	return (files);
}

static void
load_output_file(char *file)
{
	FILE *fp;
	struct fpo *lastfpo = NULL;
	char *read, *reftig, *pval, *score, *index_start, *index_end;
	char buf[512];
	uint64_t line;
	int rmapperfmt = 0;

	fp = fopen(file, "r");
	if (fp == NULL) {
		fprintf(stderr, "error: failed to open finalpass output file "
		    "[%s]: %s\n", file, strerror(errno));
		exit(1);
	}

	/*
	 * Load output generated by finalpass or rmapper. Lack of foresight
	 * left us with a bit of an ugly hack to differentiate, but it works
	 * well enough.
	 */
	reftig = NULL;
	for (line = 1; fgets(buf, sizeof(buf), fp) != NULL; line++) {
		if (buf[0] == '#') {
			char *nreftig;

			nreftig = extract_reftig(buf);
			if (nreftig != NULL) {
				rmapperfmt = 1;
				if (reftig != NULL)
					free(reftig);
				reftig = xstrdup(nreftig);
			}
		} else if (buf[0] != '#' && buf[0] != '\n') {
			struct fpo *fpo;

			if (rmapperfmt) {
				read		= strtok(buf,  "\t\r\n ");
				score		= strtok(NULL, "\t\r\n ");
				index_start	= strtok(NULL, "\t\r\n ");
				index_end	= strtok(NULL, "\t\r\n ");
				pval		= NULL;
			} else {
				read		= strtok(buf,  "\t\r\n ");
				reftig		= strtok(NULL, "\t\r\n ");
				pval		= strtok(NULL, "\t\r\n ");
				score		= strtok(NULL, "\t\r\n ");
				index_start	= strtok(NULL, "\t\r\n ");
				index_end	= strtok(NULL, "\t\r\n ");
			}

			if (read == NULL || reftig == NULL || score == NULL ||
			    index_start == NULL || index_end == NULL ||
			    (!rmapperfmt && (pval == NULL ||
			    strchr(pval, '.') == NULL))) {
				fprintf(stderr, "error: rmapper/finalpass "
				    "output file malformed at line %" PRIu64
				    "\n", line);
				exit(1);
			}

			fpo = xmalloc(sizeof(*fpo));
			fpo->read = xstrdup(trim_brackets(read));
			fpo->reftig = xstrdup(trim_brackets(reftig));
			fpo->index_start = atoi(index_start);
			fpo->index_end = atoi(index_end);
			fpo->score = atoi(score);
			fpo->next = NULL;

			if (lastfpo == NULL)
				alignments = fpo;
			else
				lastfpo->next = fpo;

			lastfpo = fpo;
			nalignments++;

			longest_genome_len = MAX(longest_genome_len,
			    fpo->index_end - fpo->index_start + 1);
		}
	}
}

static void
load_genome_file_helper(int base, ssize_t offset, int isnewentry, char *name,
    int initbp)
{
	static struct sequence *seq;
	static int first = 1;
	static ssize_t maxlen;

	/* handle initial call to alloc resources */
	if (base == FASTA_ALLOC) {
		assert(seq == NULL);
		first = 1;
		seq = xmalloc(sizeof(*seq));
		seq->sequence = xmalloc(sizeof(seq->sequence[0]) *
		    BPTO32BW(offset));
		memset(seq->sequence, 0, sizeof(seq->sequence[0]) *
		    BPTO32BW(offset));
		seq->sequence_len = 0;
		seq->name = NULL;
		maxlen = offset;

		return;
	} else if (base == FASTA_DEALLOC) {
		seq = NULL;
		return;
	}

	assert(seq != NULL);

	if (isnewentry && !first) {
		fprintf(stderr, "error: genome file consists of more than "
		    "one reftig [%s]!\n", name);
		exit(1);
	}

	if (isnewentry) {
		assert(seq->name == NULL);
		seq->name = xstrdup(name);
		seq->initbp = initbp;

		/* add to our lookup */
		if (lookup_find(reftig_list, seq->name, NULL, NULL)) {
			fprintf(stderr, "error: reftig [%s] occurs multiple "
			    "times in the read input files\n", seq->name);
			exit(1);
		}

		if (lookup_add(reftig_list, seq->name, seq) == false) {
			fprintf(stderr, "error: failed to add reftig to list - "
			    "probably out of memory\n");
			exit(1);
		}
	}

	first = 0;

	assert(seq->sequence_len < maxlen);
	assert(seq->sequence_len == offset);
	assert(base >= 0 && base <= 5);

	bitfield_append(seq->sequence, seq->sequence_len++, base);
	nreftig_bases++;
}

static void
load_genome_file(char *dir, char *file, void *arg)
{
	char fpath[PATH_MAX + 1];
	ssize_t ret;

	/* shut up, icc */
	(void)arg;

	strcpy(fpath, dir);
	strcat(fpath, "/");
	strcat(fpath, file);

	ret = load_fasta(fpath, load_genome_file_helper, LETTER_SPACE);

	if (ret == -1) {
		fprintf(stderr, "error: failed to parse reftig fasta file "
		    "[%s]\n", fpath);
		exit(1);
	}
}

static void
load_reads_file_helper(int base, ssize_t offset, int isnewentry, char *name,
    int initbp)
{
	static struct sequence *seq;
	static uint32_t *read;
	static uint32_t  read_len;

	/* shut up, icc */
	(void)offset;

	/* handle initial call to alloc resources */
	if (base == FASTA_ALLOC) {
		assert(seq == NULL);

		if (read == NULL) {
			read = xmalloc(sizeof(read[0]) *
			    BPTO32BW(MAX_READ_LEN));
			memset(read, 0, sizeof(read[0]) *
                            BPTO32BW(MAX_READ_LEN));
		}
		read_len = 0;

		return;
	} else if (base == FASTA_DEALLOC) {
		assert(read != NULL);
		if (seq != NULL) {
			seq->sequence = xmalloc(sizeof(seq->sequence[0]) *
			    BPTO32BW(read_len));
			memcpy(seq->sequence, read,
			    sizeof(seq->sequence[0]) * BPTO32BW(read_len));
			seq->sequence_len = read_len;
		}
		free(read);
		read = NULL;
		read_len = 0;
		seq = NULL;
		return;
	}

	if (isnewentry) {
		if (seq != NULL) {
			seq->sequence = xmalloc(sizeof(seq->sequence[0]) *
			    BPTO32BW(read_len));
			memcpy(seq->sequence, read,
			    sizeof(seq->sequence[0]) * BPTO32BW(read_len));
			seq->sequence_len = read_len;
		}
		seq = xmalloc(sizeof(*seq));
		seq->name = xstrdup(name);
		seq->sequence = NULL;
		seq->sequence_len = 0;
		seq->initbp = initbp;
		memset(read, 0, sizeof(read[0]) * BPTO32BW(MAX_READ_LEN));
		read_len = 0;

		/* add to our lookup */
		if (lookup_find(read_list, seq->name, NULL, NULL)) {
			fprintf(stderr, "error: read [%s] occurs multiple "
			    "times in the read input files\n", seq->name);
			exit(1);
		}

		if (lookup_add(read_list, seq->name, seq) == false) {
			fprintf(stderr, "error: failed to add read to list - "
			    "probably out of memory\n");
			exit(1);
		}
	}

	assert(seq != NULL);
	assert(read_len < MAX_READ_LEN);
	assert(base >= 0 && base <= 5);

	bitfield_append(read, read_len++, base);
	longest_read_len = MAX(longest_read_len, read_len);
	nread_bases++;
}

static void
load_reads_file(char *dir, char *file, void *arg)
{
	char fpath[PATH_MAX + 1];
	ssize_t ret;

	/* shut up, icc */
	(void)arg;

	strcpy(fpath, dir);
	strcat(fpath, "/");
	strcat(fpath, file);

	if (use_colours)
		ret = load_fasta(fpath, load_reads_file_helper, COLOUR_SPACE);
	else
		ret = load_fasta(fpath, load_reads_file_helper, LETTER_SPACE);

	if (ret == -1) {
		fprintf(stderr, "error: failed to reads parse fasta file "
		    "[%s]\n", fpath);
		exit(1);
	}
}

static unsigned int
keyhasher(void *k)
{

	return (hash_string((char *)k));
}

static int
keycomparer(void *a, void *b)
{

	return (strcmp((char *)a, (char *)b));
}

/*
 * Run through our linked list, doing S-W on the appropriate reftig
 * and read and pretty print to stdout.
 */
static void
print_alignments()
{
	struct sw_full_results sfr;
	struct sequence *read, *reftig;
	struct fpo *fpo;
	char *dbalign, *qralign;
	char *lastread = NULL;
	int ret;

	if (use_colours) {
		ret = sw_full_cs_setup(longest_genome_len, longest_read_len,
		    gap_open, gap_extend, match_value, mismatch_value,
		    xover_penalty);
	} else {
		ret = sw_full_ls_setup(longest_genome_len, longest_read_len,
		    gap_open, gap_extend, match_value, mismatch_value);
	}
	if (ret) {
		fprintf(stderr, "failed to initialise scalar Smith-Waterman "
		    "(%s)\n", strerror(errno));
		exit(1);
	}

	for (fpo = alignments; fpo != NULL; fpo = fpo->next) {
		if (lookup_find(read_list, fpo->read, NULL, (void *)&read)
		    == false) {
			fprintf(stderr, "error: read [%s] is missing\n",
			    fpo->read);
			exit(1);
		}

		if (lookup_find(reftig_list, fpo->reftig, NULL, (void *)&reftig)
		    == false) {
			fprintf(stderr, "error: reftig [%s] is missing\n",
			    fpo->reftig);
			exit(1);
		}

		if (use_colours) {
			sw_full_cs(reftig->sequence, fpo->index_start,
			    fpo->index_end - fpo->index_start + 1,
			    read->sequence, read->sequence_len,
			    read->initbp, fpo->score, &dbalign, &qralign, &sfr);
		} else {
			sw_full_ls(reftig->sequence, fpo->index_start,
			    fpo->index_end - fpo->index_start + 1,
			    read->sequence, read->sequence_len,
			    fpo->score, &dbalign, &qralign, &sfr);
		}

		sw_print_pretty(stdout, read->name, &sfr, dbalign, qralign,
		    reftig->sequence, reftig->sequence_len, fpo->index_start,
		    (lastread == NULL || strcmp(read->name, lastread) != 0));

		lastread = read->name;
	}
}

static void
usage(char *progname)
{
	char *slash;

	slash = strrchr(progname, '/');
	if (slash != NULL)
		progname = slash + 1;

	fprintf(stderr, "usage: %s output_file path_to_genomedir "
	    "path_to_readsdir\n", progname);
	exit(1);
}

int
main(int argc, char **argv)
{
	char *fpout, *readsdir, *genomedir;

	if (argc != 4)
		usage(argv[0]);

	read_list   = lookup_create(keyhasher, keycomparer, false);
	reftig_list = lookup_create(keyhasher, keycomparer, false);
	if (read_list == NULL || reftig_list == NULL) {
		fprintf(stderr, "error: failed to allocate read and reftig "
		    "lists\n");
		exit(1);
	}

	fpout     = argv[1];
	genomedir = argv[2];
	readsdir  = argv[3];

	load_output_file(fpout);
	fprintf(stderr, "Loaded %" PRIu64 " alignments from rmapper/finalpass "
	    "output\n", nalignments);

	iter_reg_files(genomedir, load_genome_file, NULL);
	fprintf(stderr, "Loaded %u genomic reftigs (%" PRIu64 " total "
	    "bases)\n", lookup_count(reftig_list), nreftig_bases);

	iter_reg_files(readsdir, load_reads_file, NULL);
	fprintf(stderr, "Loaded %u %s reads (%" PRIu64 " total bases)\n",
	    lookup_count(read_list),
	    (use_colours) ? "colourspace" : "letterspace", nread_bases);

	print_alignments();

	return (0);
}
